#+title: zshrc
#+description: This is my zshrc file
#+created: [2022-11-04 Fri 22:44]
#+last_modified: [2023-09-29 Fri 22:23]

* .zshrc
:PROPERTIES:
:header-args: :tangle ~/.dotfiles/zsh/.zshrc :mkdirp yes
:END:
** EXPORT
Here is all the export variable that I use during any zsh shell session.

#+begin_src shell
export PATH="$PATH:$HOME/tools"
export TERM="xterm-256color"                      # getting proper colors
export TERMINFO="/usr/bin/env zsh"
export HISTORY_IGNORE="(ls|cd|pwd|exit|sudo reboot|doas reboot|history|cd -|cd ..)"
export EDITOR="emacsclient -nw"              # $EDITOR use Emacs in terminal
export VISUAL="emacsclient -c -a emacs"           # $VISUAL use Emacs in GUI mode
# export VISUAL="/usr/bin/vim"
# export EDITOR="/usr/bin/vim"
export ZSH="$HOME/.oh-my-zsh"

export TZ="Europe/Paris"
#+end_src

*** Umatrix
You may need to manually set your language environment
This is the solution I found to solve my problem where umatrix wasn't printing out the latin characters.

#+begin_src shell
export LANG=en_US.utf8
export LC_CTYPE=en_US.utf8
#+end_src

*** Dotbare variable
I just use magit and setup an alias for now.
More info there [[https://www.atlassian.com/git/tutorials/dotfiles][How to Store Dotfiles - A Bare Git Repository | Atlassian Git Tutorial]].

However dotbare seems reliable as a first setup as it hangles checkouts if I
remember correctly.

#+begin_src shell
# export DOTBARE_DIR="~/.dotfiles/.git"
# export DOTBARE_TREE="~/.dotfiles"
#+end_src

** QUALITY OF LIFE
This section is where you can find anything that can be classify as quality of
life settings.

*** HISTORY TIMESTAMPS

#+begin_src shell
HIST_STAMPS="Executed the $(date +'%Y/%m/%d at %H:%mm%Ss')"
#+end_src

*** SET MANPAGER

#+begin_src shell
# broken
# export MANPAGER="sh -c 'col -b | bat -l man -p'"
# default
export MANPAGER="less"
#+end_src

I don't know why this is here..
#+begin_src shell
bindkey -v
# # if not running interactively, don't do anything
[[ $- != *i* ]] && return

autoload -U run-help
#+end_src

** ZSH THEME
Set name of the theme to load --- if set to "random", it will
load a random theme each time oh-my-zsh is loaded, in which case,
to know which specific one was loaded, run: echo $RANDOM_THEME
See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes

#+begin_src shell
ZSH_THEME="gallois"
#+end_src

Set list of themes to pick from when loading at random
Setting this variable when ZSH_THEME=random will cause zsh to load
a theme from this variable instead of looking in $ZSH/themes/
If set to an empty array, this variable will have no effect.

: ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

** COMPLETION
The following line to use case-sensitive completion.
#+begin_src shell
CASE_SENSITIVE="false"
#+end_src

The following line to use hyphen-insensitive completion.
Case-sensitive completion must be off. _ and - will be interchangeable.
#+begin_src shell
HYPHEN_INSENSITIVE="false"
#+end_src

The following line to display red dots whilst waiting for completion.
#+begin_src shell
COMPLETION_WAITING_DOTS="true"
#+end_src

** UPDATE
The following line to disable bi-weekly auto-update checks.
#+begin_src shell
DISABLE_AUTO_UPDATE="false"
#+end_src

The following line to automatically update without prompting.
#+begin_src shell
DISABLE_UPDATE_PROMPT="true"
#+end_src

The following line to change how often to auto-update (in days).
#+begin_src shell
export UPDATE_ZSH_DAYS=15
#+end_src

** EXAMPLES
:PROPERTIES:
:header-args: tangle no
:END:
The following line if pasting URLs and other text is messed up.
#+begin_src shell
DISABLE_MAGIC_FUNCTIONS="true"
#+end_src

The following line to disable colors in ls.
#+begin_src shell
DISABLE_LS_COLORS="true"
#+end_src

The following line to disable auto-setting terminal title.
#+begin_src shell
DISABLE_AUTO_TITLE="true"
#+end_src

The following line to enable command auto-correction.
#+begin_src shell
ENABLE_CORRECTION="true"
#+end_src

The following line if you want to disable marking untracked files
under VCS as dirty. This makes repository status check for large repositories
much, much faster.
#+begin_src shell
DISABLE_UNTRACKED_FILES_DIRTY="true"
#+end_src

Would you like to use another custom folder than $ZSH/custom?
#+begin_src shell
ZSH_CUSTOM=/path/to/new-custom-folder
#+end_src

Which plugins would you like to load?
Standard plugins can be found in $ZSH/plugins/
Custom plugins may be added to $ZSH_CUSTOM/plugins/
Example format: plugins=(rails git textmate ruby lighthouse)
Add wisely, as too many plugins slow down shell startup.
#+begin_src shell
plugins=(git zsh-autosuggestions)
#+end_src

Compilation flags
#+begin_src shell
export ARCHFLAGS="-arch x86_64"
#+end_src

** SOURCE
*** Oh my zsh
See oh my zsh github page.

#+begin_src shell
fpath+=${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions/src
source $ZSH/oh-my-zsh.sh
#+end_src

[[https://github.com/zsh-users/zsh-completions][GitHub - zsh-users/zsh-completions: Additional completion definitions for Zsh.]]

*** Pywal

**** Obsolete

This was for alacritty.
To add support for TTs this line can be optionally added.

#+begin_src shell
# source ~/.cache/wal/colors-tty.sh
#+end_src

pywal applying the theme to the new terminals
Import colorscheme from 'wal' asynchronously & Run the process in the background.
() Hide shell job control messages.

#+begin_src shell :tangle no
# (cat ~/.cache/wal/sequences &)
#+end_src

** SSH-AGENT

keychain keeps track of ssh-agents.

#+begin_src shell
[ -f $HOME/.keychain/$HOSTNAME-sh ] \
    && . $HOME/.keychain/$HOSTNAME-sh
#+end_src

** EDITOR LOCAL AND REMOTE
I don't know what this is...

Preferred editor for local and remote sessions

#+begin_src shell
if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='vim'
else
  export EDITOR='mvim'
fi
#+end_src

** FUNCTIONS
*** Useful for Window Managers
**** Get keyboard input

[[https://wiki.archlinux.org/title/Keyboard_input][How to get keyboard input]]

Let's you identify any keybind on your keyboard. Useful when you'are configuring
you Window Manager setup.

#+begin_src shell
describe-key ()
{
xev | awk -F'[ )]+' '/^KeyPress/ { a[NR+2] } NR in a { printf "%-3s %s\n", $5, $8 }'
}
#+end_src

**** Get wm_class
Print out the properties of any windows. This function give the wm_class
property.
Useful when you set your layout rules for your application windows treatment.

#+begin_src shell
wmclass () {
xprop | rg -ie "wm_class" | awk '{print $4}'
}
#+end_src

*** Function extract for common file formats
This function should extract any type of archive. However, you might need the
according program to extract such as 7z, zip, etc...

#+begin_src shell
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")

function extract {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
 else
    for n in "$@"
    do
      if [ -f "$n" ] ; then
          case "${n%,}" in
            *.cbt|*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar)
                         tar xvf "$n"       ;;
            *.lzma)      unlzma ./"$n"      ;;
            *.bz2)       bunzip2 ./"$n"     ;;
            *.cbr|*.rar)       unrar x -ad ./"$n" ;;
            *.gz)        gunzip ./"$n"      ;;
            *.cbz|*.epub|*.zip)       unzip ./"$n"       ;;
            *.z)         uncompress ./"$n"  ;;
            *.7z|*.arj|*.cab|*.cb7|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.pkg|*.rpm|*.udf|*.wim|*.xar)
                         7z x ./"$n"        ;;
            *.xz)        unxz ./"$n"        ;;
            *.exe)       cabextract ./"$n"  ;;
            *.cpio)      cpio -id < ./"$n"  ;;
            *.cba|*.ace)      unace x ./"$n"      ;;
            *)
                         echo "extract: '$n' - unknown archive method"
                         return 1
                         ;;
          esac
      else
          echo "'$n' - file does not exist"
          return 1
      fi
    done
fi
}

IFS=$SAVEIFS
#+end_src

Other way to extract
ex - archive extractor
usage: ex <file>

#+begin_src shell :tangle no
 ex()
 {
   if [ -f $1 ] ; then
     case $1 in
       *.tar.bz2)   tar xjf $1   ;;
       *.tar.gz)    tar xzf $1   ;;
       *.bz2)       bunzip2 $1   ;;
       *.rar)       unrar x $1   ;;
       *.gz)        gunzip $1    ;;
       *.tar)       tar xf $1    ;;
       *.tbz2)      tar xjf $1   ;;
       *.tgz)       tar xzf $1   ;;
       *.zip)       unzip $1     ;;
       *.Z)         uncompress $1;;
       *.7z)        7z x $1      ;;
       *)           echo "'$1' cannot be extracted via ex()" ;;
     esac
   else
     echo "'$1' is not a valid file"
   fi
}
#+end_src

*** SSH
This is an attempt to have a tmux session launched after a ssh connection has been estabished.

The idea here is that if I'm not wrong if you launch your tmux session before
connecting through ssh. In case the ssh connection is lost you would lose what
you were doing on the connected machine. Therefore I had the idea to write those
snippet.

start an ssh and if no tmux session exist create a session called ssh_tmux if a session already exist it attach it. NOT WORKING

#+begin_src shell :tangle no
sshtmux()
{
    # A name for the session
    local session_name="$(whoami)_sess"

    if [ ! -z $1 ]; then
        ssh -t "$1" "tmux attach -t $session_name || tmux new -s $session_name"
    else
        echo "Usage: sshtmux HOSTNAME"
        echo "You must specify a hostname"
    fi
}
#+end_src

#+begin_src shell
sshtmux()
{
    if [[ ! -z $1 && $2 ]]; then
        ssh -t "$1" "tmux attach -t $2 || tmux new -s $2"
    else
        echo "Usage: sshtmux HOSTNAME SESSION_NAME"
        echo "You must specify a hostname and a session name"
    fi
}
#+end_src

#+begin_src shell :tangle no
tmuxattach()
{
    if [ ! -z $1 ]; then
        tmux attach-session -t $1 || tmux new-session -s $1
    else
        echo "Usage: tmuxattach SESSION_NAME"
        echo "You must specify a session name"
    fi
}
#+end_src

*** navigation
up 2 <-> cd ../../

#+begin_src shell
up () {
  local d=""
  local limit="$1"

  # Default to limit of 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  for ((i=1;i<=limit;i++)); do
    d="../$d"
  done

  # perform cd. Show error if cd fails
  if ! cd "$d"; then
    echo "Couldn't go up $limit dirs.";
  fi
}
#+end_src

*** Zellij
I need to make those scripts so that I can use them with my WM.
Change their alias name so that it doesn't conflict with the scripts

[[https://zellij.dev/documentation/integration.html][Integration - Zellij User Guide]]

**** Zellij choose sessions
List all ~zellij~ session and let you select one.

#+begin_src shell :tangle no
zjs() {
    ZJ_SESSIONS=$(zellij list-sessions)
    zellij attach \
    "$(echo "${ZJ_SESSIONS}" | sk)"
}
#+end_src

**** Zellij select layout

List all of my personal for ~zellij~ and apply it to the lauched session.

#+begin_src shell :tangle no
zjl() {
    ZJ_LAYOUT_DIR=$(zellij setup --check \
        | grep "LAYOUT DIR" - \
        | grep -o '".*"' - | tr -d '"')

    if [[ "$#" -eq 1 ]]; then
        if [[ -d "${ZJ_LAYOUT_DIR}" ]];then
            ZJ_LAYOUT="$(fd --type file . "${ZJ_LAYOUT_DIR}" \
            | sed 's|.*/||' \
            | sk \
            || exit)"
              zellij --layout "${ZJ_LAYOUT}" --session "$1"
            fi
    else
        echo "Usage: $0 [zellij-session-name]"
    fi
}
#+end_src

**** Zellij attach or start session

This function take a session name and either start a new session or attach it if
the session name already exist.

#+begin_src shell :tangle no
zj() {
    if [[ $# -eq 1 ]]; then
        if [[ -z "$ZELLIJ" ]]; then
            zellij -s "$1" || zellij a "$1"
        elif [[ -n "$ZELLIJ" ]]; then
            echo "Nest is bad, right?"
        fi
    else
        echo "Usage: $0 [zellij-session-name]"
    fi
}
#+end_src

*** Convert
function to convert png to ico.

https://askubuntu.com/questions/867567/convert-jpg-or-png-to-ico-using-terminal-and-back

#+begin_src shell
png2ico () {
    local i="${1}" o="${2:-${1:r}.ico}" s="${png2ico_size:-256}"
    convert -resize x${s} -gravity center -crop ${s}x${s}+0+0 "$i" -flatten -colors 256 -background transparent "$o"
}
#+end_src

*** man width
I'm not sure if I really need that.

source: [[https://wiki.archlinux.org/title/Man_page][man page - ArchWiki]]

#+begin_src shell :tangle no
man() {
    local width=$(tput cols)
    [ $width -gt $MANWIDTH ] && width=$MANWIDTH
    env MANWIDTH=$width \
    man "$@"
}
#+end_src

** ALIASES

Set personal aliases, overriding those provided by oh-my-zsh libs,
plugins, and themes. Aliases can be placed here, though oh-my-zsh
users are encouraged to define aliases within the ZSH_CUSTOM folder.
For a full list of active aliases, run `alias`.

*** root privileges

#+begin_src shell
alias pacman='sudo pacman'
alias mount='sudo mount'
alias umount='sudo umount'
#+end_src

*** source file

#+begin_src shell
alias sz="source ~/.zshrc"
alias sv="source ~/.vimrc"
#+end_src

*** dotfiles gitbare
See [[https://www.atlassian.com/git/tutorials/dotfiles][How to Store Dotfiles - A Bare Git Repository | Atlassian Git Tutorial]] for
more informations.

#+begin_src shell
alias dotfiles="git --git-dir=$HOME/.dotfiles/.git --work-tree=$HOME/.dotfiles"
#+end_src

*** hack
#+begin_src shell
alias listener="rlwrap nc -lnvp"
alias htpd="python -m http.server 7777"
alias nping="nmap -sn -n --disable-arp-ping"
# I need to investigate this or maybe write a plugin for zellij
# alias logger="script -a $HOME/.sessions/$(date +"%Y-%m-%dT%H:%M:%S")-typescript.out"
alias zz="zellij"
#+end_src
*** vim and emacs

#+begin_src shell
alias v="vim"
alias vi="vim"
alias e="emacsclient -nw"
alias em="emacsclient -nw"
#+end_src

*** Changing "cat" to "bat"

#+begin_src shell
alias cat='bat'
#+end_src

*** Changing "ls" to "exa"
#+begin_src shell
alias ls='eza' # my preferred listing
alias la='eza -a --color=always --group-directories-first'  # all files and dirs
alias ll='eza -l --color=always --group-directories-first'  # long format
alias lt='eza -aT --color=always --group-directories-first' # tree listing
alias l.='eza -a | rg "^\."'
#+end_src

*** pacman, pikaur
#+begin_src shell
# alias pacup='yes | pacman -Syu'
alias pacsyu='pacman -Syu'                     # update only standard pkgs
alias pacsyyu='pacman -Syyu'                   # Refresh pkglist & update standard pkgs
alias paclog='vim /var/log/pacman.log'              # look for pacman logs
alias piksua='pikaur -Sua --noconfirm'              # update only AUR pkgs (pikaur)
alias piksyu='pikaur -Syu --noconfirm'              # update standard pkgs and AUR pkgs (pikaur)
alias unlock='rm /var/lib/pacman/db.lck'       # remove pacman lock
alias cleanup='pacman -Rns $(pacman -Qtdq)'     # remove orphaned packages
#+end_src

**** get fastest mirrors
#+begin_src shell
alias mirror="sudo reflector -f 30 -l 30 --number 10 --verbose --save /etc/pacman.d/mirrorlist"
alias mirrord="sudo reflector --latest 50 --number 20 --sort delay --save /etc/pacman.d/mirrorlist"
alias mirrors="sudo reflector --latest 50 --number 20 --sort score --save /etc/pacman.d/mirrorlist"
alias mirrora="sudo reflector --latest 50 --number 20 --sort age --save /etc/pacman.d/mirrorlist"
#+end_src

*** Changing grep for ripgrep
Remember to ~/usr/bin/grep~ if you want to use grep.

#+begin_src shell
# alias grep='rg'
#+end_src

*** adding flags
???

#+begin_src shell
alias df='df -h'                          # human-readable sizes
alias free='free -m'                      # show sizes in MB
# alias vifm='./.config/vifm/scripts/vifmrun'
#+end_src

I forgot what this was about I might have take that somewhere...
#+begin_src shell
alias ncmpcpp='ncmpcpp ncmpcpp_directory=$HOME/.config/ncmpcpp/'
alias mocp='mocp -M "$XDG_CONFIG_HOME"/moc -O MOCDir="$XDG_CONFIG_HOME"/moc'
#+end_src

*** ps

#+begin_src shell
alias psa="ps auxf"
alias psgrep="ps aux | grep -v grep | grep -i -e VSZ -e"
alias psmem='ps auxf | sort -nr -k 4'
alias pscpu='ps auxf | sort -nr -k 3'
#+end_src

*** get error messages from journalctl

#+begin_src shell
alias jctl="journalctl -p 3 -xb"
#+end_src

*** gpg encryption
verify signature for isos

#+begin_src shell
alias gpg-check="gpg2 --keyserver-options auto-key-retrieve --verify"
#+end_src

receive the key of a developer

#+begin_src shell
alias gpg-retrieve="gpg2 --keyserver-options auto-key-retrieve --receive-keys"
#+end_src

*** switch between shells
Nice to have around.

#+begin_src shell
alias tobash="sudo chsh $USER -s /bin/bash && echo 'Now log out.'"
alias tozsh="sudo chsh $USER -s /bin/zsh && echo 'Now log out.'"
#+end_src

*** reset $PATH
I made some mistake with my ~PATH~ so this is nice to be able to reset it to
factory parameters.

[[https://askubuntu.com/questions/113419/how-can-i-reset-path-to-its-default-value-in-ubuntu][command line - How can I reset $PATH to its default value in Ubuntu? - Ask Ub...]]

#+begin_src shell
alias getpath="PATH=$(/usr/bin/getconf PATH)"
#+end_src

** COLORSCRIPT
This print some image when you start your terminal.

#+begin_src shell
colorscript random
#+end_src

** zellij (multiplexer)
Autostart on shell creation

Failed attempt at making zellij and script working togeter but as they are both
interactive I haven't been able to make them work yet. Maybe check tmux as there
is a plugin for that. Perhaps, there might be some command in the source code that are
worth checking.

#+begin_src shell
# export ZELLIJ_AUTO_ATTACH=true
# export ZELLIJ_AUTO_EXIT=true
# eval "$(zellij setup --generate-auto-start zsh)"
# eval "$(zellij.sh)"
#+end_src
